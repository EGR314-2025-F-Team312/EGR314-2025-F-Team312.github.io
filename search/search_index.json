{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"Project Firesight <p> Team Embermen</p> <p> Hannah Nair, Luke Willet, Musye Gaim, Joshua Petrone</p> <p> Fall 2025</p> <p> ASU, Class 2026, Professor Suo</p> <p>Preparation Date: December, 7th, 2025 </p><p></p>","tags":["tag1","tag2"]},{"location":"#project-summary","title":"Project Summary","text":"<p>Project Firesight is a wireless weather station network that sends real-time environmental data to a central control panel. The weather stations utilize the BME280 sensor, which measures the environment's temperature, relative humidity, and pressure. The central control panel has rows of indicator LEDs for each environmental variable measured, where each row represents one weather station. On the end of each row is a red indicator LED, which lights when that weather station's area is deemed susceptible to wilfires, i.e. when two out of three of the envionmental indicator LEDs light up. Project Firesight allows the user to detect wildfire susceptible areas BEFORE a potential wildfire starts, creating a proactive approach to fighting wildfires which increases the efficiency by which wildfires are suppressed. </p> <p>Figure 1: Project Firesight - Weather Station </p> <p>Figure 2: Project Firesight - Control Panel </p> <p>Figure 3: Project Firesight - Weather Station PCB </p> <p>Note: The weather station PCB is the green PCB. During integration, the microcontroller on the weather station PCB fried, so the blue PCB's microcontroller was used. </p>","tags":["tag1","tag2"]},{"location":"#summary-table-of-major-components","title":"Summary Table of Major Components","text":"Part Name/Description Unit Quantity Unit Cost Manufacturer Manufacturer Part # Vendor Total Cost Order Total IC REG BUCK 3V 3A TO263 4 $3.32 Texas Instruments LM2596S-(3.3V)/NOPB Digikey $13.28 $168.73 9V 12 W AC/DC External Wall Mount (Class II) Adapter Fixed Blade Input 1 $6.23 GlobTek, Inc. 1939-WR9HD1333CCP-F(R6B)-ND Digikey $6.23 BME 280 Breakout Board 2 $8.99 HiLetgo GY-BME280-3.3 Amazon $17.98 LED RED DIFFUSED GULL WING SMD 5 $2.01 Broadcom Limited HLMP-Q150-F0011 Digikey $10.05 LED BLUE ROUND 4SMD 25 $1.20 Broadcom Limited ALMD-CB1E-VW002 Digikey $30.00 Junction box enclosure.  5.9\"D x 10.6\"W x 14.6\"H 1 $49.99 Gratury G Amazon $49.99 ESP32 Microcontroller 5 $5.06 Espressif Systems ESP32-S3-WROOM-1-N4 Digikey $25.30 ESP32 Snap Programmer 3 $5.30 M5 Stack S006 Electromaker $15.90 <p>Note: The motor driver, DC motor, and internal temperature sensor were not included in the final prototype as the motor driver was unable to be properly soldered with the surface mount equipment provided at Peralta Lab. The OUT+ and OUT- pins that drive the motor would consistently short with the GND pin on the driver due to how small the driver and the pads were. Thus, the motor and related components are left out of the summary table as they were unused.</p>","tags":["tag1","tag2"]},{"location":"#page-links","title":"Page Links","text":"<p>Team Organization</p> <p>Ideation and Concept Generation</p> <p>Component Selection</p> <p>Block Diagram</p> <p>Bill of Materials</p> <p>Final Schematic &amp; PCB</p> <p>Innovation Showcase Poster</p> <p>Project Resources</p> <p>Reflection</p>","tags":["tag1","tag2"]},{"location":"BOM/","title":"Final Bill of Materials","text":"<p>The final bill of materials for this project is detailed in the table below. Most of the items were sourced from Digikey, however, some were sourced from Amazon. For example, the underground box had to be sourced from Amazon as that is the only place which carried that specific product. It does not come with a datasheet, but it is also just a box.  </p> Part Name/Description Unit Quantity Unit Cost Manufacturer Manufacturer Part # Vendor Total Cost Order Total IC REG BUCK 3V 3A TO263 4 $3.32 Texas Instruments LM2596S-(3.3V)/NOPB Digikey $13.28 $292.91 FIXED IND 33UH 4.1A 92 MOHM SMD 5 $0.80 Sumida America Components Inc. 104CDMCCDS-330MC Digikey $4.00 Diode 30 V 5A Surface Mount SMC 5 $0.61 Diodes Incorporated B530C-13-F Digikey $3.05 680 \u00b5F Molded Tantalum Polymer Capacitor 6.3 V 2917 (7343 Metric) 18mOhm @ 100kHz 5 $2.90 Panasonic Electronic Components 6TPE680MI Digikey $14.50 220 \u00b5F \u00b120% 6.3V Ceramic Capacitor X5R 1206 (3216 Metric) 5 $1.22 Murata Electronics GRM31CR60J227ME11L Digikey $6.10 9V 12 W AC/DC External Wall Mount (Class II) Adapter Fixed Blade Input 1 $6.23 GlobTek, Inc. 1939-WR9HD1333CCP-F(R6B)-ND Digikey $6.23 Power Barrel Connector Jack 2.10mm ID (0.083\"), 5.50mm OD (0.217\") Through Hole, Right Angle 5 $1.14 Same Sky (Formerly CUI Devices) CP-202AH-ND Digikey $5.70 BME 280 Breakout Board 2 $8.99 HiLetgo GY-BME280-3.3 Amazon $17.98 Multilayer Ceramic Capacitors MLCC - SMD/SMT 100V .1uF X7R 0805 1 0% 20 $0.13 Kyocera AVX KGM21AR72A104KU Mouser Electronics $2.60 RES 4.7K OHM 5% 1/16W 0402 20 $0.10 YAGEO RC0402JR-074K7L Digikey $2.00 LED RED DIFFUSED GULL WING SMD 5 $2.01 Broadcom Limited HLMP-Q150-F0011 Digikey $10.05 LED BLUE ROUND 4SMD 25 $1.20 Broadcom Limited ALMD-CB1E-VW002 Digikey $30.00 220 Ohms \u00b11% 2W Chip Resistor 2512 (6332 Metric) Moisture Resistant Thick Film 25 $0.88 Stackpole Electronics Inc RHC2512FT220R Digikey $22.00 Junction box enclosure.  5.9\"D x 10.6\"W x 14.6\"H 1 $49.99 Gratury G Amazon $49.99 SENSOR DIGITAL -40C-125C SOT23-5 5 $1.15 Microchip Technology TC74A4-3.3VCTTR Digikey $5.75 CAP CER 1UF 10V X7R 0603 25 $0.08 Samsung Electro-Mechanics CL10B105KP8NNNC Digikey $2.00 DRV8838DSGR Motor Driver 5 $1.03 Texas Instruments DRV8838DSGR Digikey $5.15 DC Motor (3-6V) 5 $2.95 Adafruit Industries LLC 3777 Digikey $14.75 ESP32 Microcontroller 5 $5.06 Espressif Systems ESP32-S3-WROOM-1-N4 Digikey $25.30 10kOhm Resistor 25 $0.10 YAGEO RC1206FR-1310KL Digikey $2.50 5.1kOhm Resistor 25 $0.10 YAGEO RC0805JR-075K1L Digikey $2.50 Micro USB port 5 $1.02 Kycon, Inc. KMMX-BSMT35S-B30TR Digikey $5.10 22 uF Ceramic Capacitor 25 $0.13 Samsung Electro-Mechanics CL21A226KQCLRNC Digikey $3.25 Push button 20 $0.18 Same Sky (Formerly CUI Devices) TS04-66-50-BK-160-SMT Digikey $3.60 Female header pins 4 $2.95 Adafruit Industries LLC 598 Digikey $11.80 Male header pins 9 $0.87 W\u00fcrth Elektronik 61301611121 Digikey $7.83 ESP32 Snap Programmer 3 $5.30 M5 Stack S006 Electromaker $15.90"},{"location":"BlockDiag/","title":"Block Diagram & Communication Sequence Diagram","text":"<p>The block diagram below details how the subsystems within Project Firesight interact with each other. The power subsystem takes in power from the battery and output 3.3 volts to all other subsytems for both the weather station and control panel. The internal temperature sensor, and the external environment sensor communicate with the microcontroller chip through I2C. The environmental sensor data (temperature, pressure, and relative humidity) is relayed to the control panel's microcontroller through the ESP-NOW communication protocol. The second weather station block (shown on the top right) relays it's environmental information to the control panel through the first weather station block using ESP-NOW. The control panel receives this data, compares it to the threshold values, and lights up LEDs correspondingly. </p> <p>Figure 1: Project Firesight Block Diagram</p> <p></p>"},{"location":"BlockDiag/#decision-making-process-product-requirements","title":"Decision Making Process &amp; Product Requirements","text":"<p>The decision making process for structuring the block diagram above revolved around simplicity and the examples given in class. The block diagram meets our product requirements as it measures three different types of environmental data from multiple stations, relays that data back to the control panel via ESP-NOW wireless communication, and the control panel actuates corresponding LEDs based on the data received. By doing so, the stakeholders receive real-time environmental data and information on areas that could produce a wildfire, which allows for proactiveness in wildfire suppression. All boards receive stable power, which is critical in allowing the project to function. Lastly, our block diagram showcases four subsystems working together (power, control panel LED actuators, wireless communication, microcontroller), which satisfies the product requirement of four subsystems working together. </p>"},{"location":"BlockDiag/#communication-sequence-diagram","title":"Communication Sequence Diagram","text":"<p>The communication sequence diagram, in the figure below, satisfies user needs and product requirements by initializing ESP-NOW communication between all weather stations and the control panel, continuosly reading environmental data from the BME280 sensors for each weather station, and sending that data back to the control panel. If the control panel receives a data packet that is the length expected, it will decode that data, store it in it's respective environmental data variables, and light up LEDs correspondingly if the environmental data surpasses the threshold value. If the length of the packet does not match what is expected, that data packet is ignored. Initializing ESP-NOW communication allows for wireless communication and reduces disruption to the environment that the weather stations are in, which satisfies the wireless communication product requirement and the user need of minimizing environmental disruptions. Checking the packet length ensures that no data is received that is not from the weather stations, which verifies that accurate data is received by the control panel, allowing for proactive wildfire supression. </p> <p>Figure 2: Communication Sequence Diagram </p>"},{"location":"BlockDiag/#communication-message-structure","title":"Communication Message Structure","text":"<p>The communication message structure for the environmental data was structured to be as simple as possible. The structure of the message from the weather stations is a float variable for temperature, pressure, and relative humidity, and an unsigned integer for a time stamp that the data was sent, using the millis() function. The weather stations send their environmental data every loop scan, and the control panel processes that environmental data packet every time an ESP-NOW message arrives on radio via the esp_now_register_recv_cb() function and the OnDataRecv() function, which are built in ESP-NOW library functions. Please see the Appendix for the full control panel and weather station code. </p>"},{"location":"BlockDiag/#top-five-software-changes","title":"Top Five Software Changes","text":""},{"location":"BlockDiag/#micropython-to-c","title":"Micropython To C++","text":"<p>The code was initially set to be programmed through micropython. However, due to continuous microcontroller programming issues with VS Code Pymakr extension, and the lack of time available to translate the example ESP-NOW Arduino code given in class (which was in C++) to micropython, the software was written in C++ instead and programmed through Platform IO, as that was proven to work with previous lab assignments. </p>"},{"location":"BlockDiag/#adding-serial-print-lines-for-esp-now-debugging","title":"Adding Serial Print Lines for ESP-NOW Debugging","text":"<p>The initial code written had no serial print lines to dictate which part of the code has been executed. This provided the team with no feedback on what part of the code was not working, which makes debugging immensely difficult. Thus, serial print lines were added in sections of the code to communicate which sections of the code processed, and where it was stuck. </p>"},{"location":"BlockDiag/#time-stamp-data-addition","title":"Time Stamp Data Addition","text":"<p>When the code first worked, environmental data was measured and successfully sent over to the control panel. However, when trying to trigger all LEDs for demonstration purposes, it was difficult determining if the environmental data was stagnating (and therefore, not reaching the threshold values to trigger the LEDs), or if the ESP-NOW connection was lost. A time stamp variable was added to the data payload to fix this, as it would ALWAYS change each time the environmental data was received. </p>"},{"location":"BlockDiag/#pwm-breathing-code-library","title":"PWM Breathing Code Library","text":"<p>Initially, the PWM breathing code for the LEDs was written by utilizing the analogWrite() function within Arduino. However, further research found that ESP32 has a built in PWM controller library for LEDs. To increase simplicity and code readability, this library was utilized. </p>"},{"location":"BlockDiag/#pwm-breathing-delay","title":"PWM Breathing Delay","text":"<p>The initial delay that determined how intense the LEDs would breathe was accomplished by the delay() function. However, since multiple LEDs may be breathing at the same time, the delay() function could not be utilized as it stops the microcontroller frome executing any code at all. To fix this, the millis() function was utilized and compared to a time stamp constant. </p>"},{"location":"concept_gen/","title":"Ideation and Concept Generation","text":""},{"location":"concept_gen/#learning-about-wildfire-response-potential-stakeholders","title":"Learning about Wildfire Response &amp; Potential Stakeholders","text":"<p>The goal of our project is to provide a proactive approach to wildfire management and suppression. During the in-class stakeholder interview, the stakeholder spokesperson detailed that they only conduct a reactive approach to fighting wildfires; drones are only utilized to capture visual, thermal, and atmospheric details of an ongoing wildfire. Furthermore, the drones\u2019 battery life only lasts for an hour, which limits the amount of data that can be collected. The spokesperson detailed that they receive predictive weather information from an outside organization, but did not describe how they process or utilize that information, or how long it takes for that information to be given. With the increasing unpredictability of weather phenomena, it is important that these extreme weather/environmental organizations have accurate, real-time data available. </p> <p>Thus, Project Firesight's purpose is to create a wireless weather station network that will measure and transmit real-time weather data to a main control panel. Each weather station will measure atmospheric details, such as wind speed, air humidity, ground &amp; air temperature, ground moisture, and more. This data will be sent to a primary control panel, which will have indicator LEDs to alert to the status of each weather station and indicate whether the area it is in is susceptible to wildfires. </p> <p>The audience for our project is both in academia and in industry. These stakeholders are our professor, Dr. Dajiang Suo, our teaching assistants, the State of Arizona\u2019s Department of Forestry and Fire Management, local fire departments, local, state, and/or federal environmental agencies, environmental or wildlife research groups, and local residential communities. Our stakeholders can even extend to Arizona\u2019s state government, as extreme wildfires can produce a domino effect of consequences that affect Arizona as a whole. </p>"},{"location":"concept_gen/#idea-generation-initial-concept","title":"Idea Generation &amp; Initial Concept","text":"<p>The initial design concept's decision making process was through generating as much ideas as possible, organizing those generated ideas into grouped themes, ranking those grouped ideas based on feasibility and stakeholder needs, and finally, combining the highest ranked ideas. Please see the Appendix for a detailed description of the initial design concept's decision making process. </p> <p>A concept sketch was built out of everyday materials to envision Project Firesight. The figure below depicts the initial concept sketch.</p> <p>Figure 1: Initial Concept Sketch</p> <p></p> <p>The features in our concept sketch satisfy the needs for wildfire response organizations by providing real-time data through wireless communication and the incorporation of a durable mechanical casing. </p> <p>The wireless communication significantly reduces the amount of physical interaction between the product and the environment, satisfying the need for environmental protection. </p> <p>The real-time data provides the opportunity for wildfire-related organizations to develop a proactive response, which increases the efficiency by which wildfire organizations can complete their duties. </p> <p>Furthermore, the mechanical protection, underground safety feature, and durability of the product ensures that it will survive in extreme weather conditions, which satisfies the need for a reliable &amp; durable product. </p> <p>The control panel will show when certain environmental thresholds are met and have an indicator to when a certain area becomes a threat for a wildfire. The control panel will be a grid of LED lights that correspond to the type of measured environmental variable on the columns, and the rows represent each weather station. The last LED in each row will indicate if an area is deemed wildfire-susceptibile. Please see the Appendix for information on how the subsystems were split between the team members. </p> <p>Our product will include labels on the control panel for each LED and each row, which indicate their function. The \u2018wildfire susceptible\u2019 LEDs (which indicate if the area the station is in is wildfire susceptible) will \u201cbreathe\u201d using PWM. As a stretch goal, our product could increase the intensity by which the LED breathes for added indication. </p> <p>Durability, safety, and comfort will be very important to the end product because the installment of our modules is in remote and hard to reach areas, which is not something anyone wants to install twice. Durability during any sort of weather these areas can throw at us is of utmost importance, as no data can be transmitted if the station is incapacitated. Project Firesight will make sure wildlife does not interact with the product, as a curious animal may be able to destroy the product or hurt itself in the process. Most importantly, the product must not be harmful to any ecosystems that it is within. </p> <p>The modules will have to be calibrated to each other and confirm that all the modules are functioning together and communicating to the main control panel. To conduct this effectively, an instruction and maintenance manual will be provided that will cover the specifics.</p> <p>Below is a YouTube presentation on Project Firesight's idea generation process:</p> <p>Note: The pictures utilized in the YouTube presentation are AI generated. </p>"},{"location":"concept_gen/#final-design-concept","title":"Final Design Concept","text":"<p>The final design concept remained centered around a wireless weather station network transmitting environmental data to a central control panel. However, the final design concept did not include the HMI screen, solar panels, antenna, and antenna wiring conduit. The final concept also modified the underground feature. Below is a description of why each component was not included in the final design, and how the underground feature was modified. </p>"},{"location":"concept_gen/#hmi-screen","title":"HMI Screen","text":"<p>The HMI screen was not included due to budget and time constraints. The purpose of the HMI screen during intial concept generation was to adjust the threshold values for each environmental variable, as different seasons of the year could change the conditions that create a wildfire. The HMI screen that fit within our project's deadline was the Nextion HMI Screen, which costs around 80 dollars if bought from Digikey. All critical subsystems and supporting items created a project cost of approximately 280 dollars. Thus, adding the HMI screen would put the project over budget. </p>"},{"location":"concept_gen/#solar-panels","title":"Solar Panels","text":"<p>The solar panels were not included due to budget constraints. The lithium batteries utilized had to be at least 7.4 volts due to the voltage input requirements of our voltage regulator. The purpose of the solar panels was to charge the lithium ion batteries, and therefore decrease the amount of maintenance on the weather stations. To incorporate solar panels in this manner, a solar charge controller board must be utilized to ensure the batteries are not overcharged. However, it was incredibly difficult finding a solar charge controller board that could take in 7.4 volts while also remaining within budget.</p>"},{"location":"concept_gen/#antenna-antenna-wiring-conduit","title":"Antenna &amp; Antenna Wiring Conduit","text":"<p>The antenna was not included due to budget constraints. Furthermore, as this is a school project and not a full-fledged product, the team decided that the built in antenna on the microcontroller chip was sufficient. The wiring conduit is for the antenna and environmental sensors; the wiring conduit was removed as well since the antenna is no longer included, and the environmental sensors do not need external conduit due to modifications on the underground safety feature. </p>"},{"location":"concept_gen/#modified-underground-safety-feature","title":"Modified Underground Safety Feature","text":"<p>The underground safety feature was modified to incorporate an electrical component based on feedback from the professor and TA's. The underground safety feature now includes a temperature sensor to measure the temperature INSIDE the weather station enclosure, a DC motor &amp; motor driver, and a small 3D printed pin that will be pulled by the motor. The weather station PCB will still sit in its enclosure, but the enclosure will now be placed between sliders. The weather station's sliders will be fully extended; The motor pin will be mounted such that it \"locks\" the sliders in their fully extended position. Half of the length of the sliders will be in an underground hole, the other half will be above the hole to allow the environmental sensor to measure accurate data. Once the INTERNAL temperature sensor measures a temperature that could destroy the weather station's electronics, the DC motor will pull the motor pin, which will drop the weather station enclosure into the hole. This will ensure that the weather station's electronics will be safe if a wildfire is active in the weather station's area. Below is a concept sketch of the final concept design. </p> <p>Figure 2: Final Concept Sketch</p> <p></p>"},{"location":"esp32-pinout-table/","title":"ESP32 Pinout Table","text":""},{"location":"esp32-pinout-table/#control-panel-board","title":"Control Panel Board","text":"GPIO Pin # Function Connects To What Board Component 0 MCU Boot Pin Snap Programmer Boot Male Header Pin, Boot Male Header Pin 1 UART RX UART RX Male Header Pin 2 UART TX UART TX Male Header Pin 4 Weather Station 1 Temperature LED Signal Weather Station 1 Temperature 220 Ohm Resistor 5 Weather Station 1 Relative Humidity LED Signal Weather Station 1 Relative Humidity 220 Ohm Resistor 6 Weather Station 1 Pressure LED Signal Weather Station 1 Pressure 220 Ohm Resistor 7 Weather Station 1 Wildfire LED Signal Weather Station 1 Wildfire 220 Ohm Resistor 9 Weather Station 2 Temperature LED Signal Weather Station 2 Temperature 220 Ohm Resistor 10 Weather Station 2 Relative Humidity LED Signal Weather Station 2 Relative Humidity 220 Ohm Resistor 11 Weather Station 2 Pressure LED Signal Weather Station 2 Pressure 220 Ohm Resistor 12 Weather Station 2 Wildfire LED Signal Weather Station 2 Wildfire 220 Ohm Resistor 13 VBUS Sense Between 100kOhm and 150 kOhm Resistors 19 Data Minus Pin Micro USB-B Data Minus Pin 20 Data Plus Pin Micro USB-B Data Plus Pin 43 TXD0 MCU Programming Snap Programmer TXD0 Male Header Pin 44 RXD0 MCU Programming Snap Programmer RXD0 Male Header Pin EN MCU Enable Pin EN Push Button, 0.1uF Capacitor, Snap Programmer EN Male Header Pin"},{"location":"esp32-pinout-table/#weather-station-board","title":"Weather Station Board","text":"GPIO Pin # Function Connects To What Board Component 0 MCU Boot Pin Snap Programmer Boot Male Header Pin, Boot Male Header Pin 1 UART RX UART RX Male Header Pin 2 UART TX UART TX Male Header Pin 4 Motor Driver Sleep Logic Pin Motor Driver Sleep Pin 5 VBUS Sense Between 100kOhm and 150 kOhm Resistors 6 Motor Driver PH Logic Pin Motor Driver PH Pin 7 Motor Driver EN Logic Pin Motor Driver EN Pin 8 Serial Data Line (SDA) SDA Screw Terminal, 4.7 kOhm Resistor, Sensor SDA Pins 9 Serial Clock Line (SCL) SCL Screw Terminal, 4.7 kOhm Resistor, Sensor SCL Pins 19 Data Minus Pin Micro USB-B Data Minus Pin 20 Data Plus Pin Micro USB-B Data Plus Pin 43 TXD0 MCU Programming Snap Programmer TXD0 Male Header Pin 44 RXD0 MCU Programming Snap Programmer RXD0 Male Header Pin EN MCU Enable Pin EN Push Button, 0.1uF Capacitor, Snap Programmer EN Male Header Pin"},{"location":"innovation-showcase-poster/","title":"Innovation Showcase Poster","text":"<p>The figure below is Project Firesight's poster, made for ASU Polytechnic's Innovation Showcase (Fall 2025). Below the figure is a link to a PDF version of the poster. </p> <p>Figure 1: Project Firesight Poster</p> <p></p> <p>Link to PDF Document</p>"},{"location":"project-resources/","title":"Project Resources","text":""},{"location":"project-resources/#final-prototype-project-pictures","title":"Final Prototype Project Pictures","text":""},{"location":"project-resources/#control-panel","title":"Control Panel","text":"<p>Figure 1: Control Panel </p>"},{"location":"project-resources/#weather-station","title":"Weather Station","text":"<p>Figure 2: Weather Station </p>"},{"location":"project-resources/#weather-station-pcb","title":"Weather Station PCB","text":"<p>Figure 3: Weather Station PCB </p> <p>Note: The weather station PCB is the green PCB. During system integration, the microcontroller on the weather station PCB fried. For final demonstration, power was routed through the weather station PCB's power system to the blue PCB to utilize it's microcontroller. </p> <p></p>"},{"location":"project-resources/#project-demonstration-video","title":"Project Demonstration Video","text":""},{"location":"project-resources/#project-functionality-testing-video","title":"Project Functionality Testing Video","text":""},{"location":"project-resources/#project-code","title":"Project Code","text":""},{"location":"project-resources/#control-panel-code-c","title":"Control Panel Code (C++)","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;esp_now.h&gt;\n#include &lt;esp_wifi.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n\n//LED Pins\nconst int temp1Pin     = 4;\nconst int humidity1Pin = 5;\nconst int pressure1Pin = 6;\nconst int wildfire1Pin = 7;\n\nconst int temp2Pin     = 9;\nconst int humidity2Pin = 10;\nconst int pressure2Pin = 11;\nconst int wildfire2Pin = 12;\n\n//PWM settings\nconst int freq = 5000;\nconst int resolution = 8;   // 0-255\n\n//Fade state\nint duty1 = 0, dir1 = +1;\nint duty2 = 0, dir2 = +1;\nint duty3 = 0, dir3 = +1;\nint duty4 = 0, dir4 = +1;\n\nconst uint32_t fadeIntervalMs = 15;\nconst int fadeSize = 5;\n\nuint32_t lastFadeStep1 = 0;\nuint32_t lastFadeStep2 = 0;\nuint32_t lastFadeStep3 = 0;\nuint32_t lastFadeStep4 = 0;\n\n// data payload\ntypedef struct __attribute__((packed)) {\n  float    tempC;         // \u00b0C\n  float    pressure_hPa;  // hPa\n  float    humidity_pct;  // %RH\n  uint32_t timestamp_ms;  // sender millis()\n} telemetry_struct;\n\ntelemetry_struct receivedData;\n\n// Latest readings accessible from loop()\nvolatile float latestTempC = NAN;\nvolatile float latestPressure_hPa = NAN;\nvolatile float latestHumidity_pct = NAN;\nvolatile uint32_t latestTimestamp = 0;\n\nbool wildfireActive = false; \n\nstatic void printMACAddress(const uint8_t *mac) {\n  Serial.printf(\"%02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n}\n\nstatic void printStaMac() {\n  uint8_t mac[6];\n  esp_wifi_get_mac(WIFI_IF_STA, mac);\n  Serial.printf(\"%02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n}\n\n// ESP-NOW receive callback\nvoid OnDataRecv(const esp_now_recv_info_t *info, const uint8_t *incomingData, int len) {\n  if (len != (int)sizeof(telemetry_struct)) {\n    Serial.printf(\"Received %d bytes (expected %d). Ignoring.\\n\",\n                  len, (int)sizeof(telemetry_struct));\n    return;\n  }\n\n  memcpy(&amp;receivedData, incomingData, sizeof(receivedData));\n\n  // Update \"latest\" globals\n  latestTempC = receivedData.tempC;\n  latestPressure_hPa = receivedData.pressure_hPa;\n  latestHumidity_pct = receivedData.humidity_pct;\n  latestTimestamp = receivedData.timestamp_ms;\n\n  Serial.print(\"From: \");\n  printMACAddress(info-&gt;src_addr);\n\n  Serial.printf(\"Temp: %.2f C, Pressure: %.2f hPa, Humidity: %.2f %% | timestamp_ms: %lu\\n\\n\",\n                receivedData.tempC,\n                receivedData.pressure_hPa,\n                receivedData.humidity_pct,\n                (unsigned long)receivedData.timestamp_ms);\n}\n\nstatic void stepFade(int pin, int &amp;duty, int &amp;dir) {\n  duty += dir * fadeSize;\n  if (duty &gt;= 255) { duty = 255; dir = -1; }\n  if (duty &lt;= 0)   { duty = 0;   dir = +1; }\n  ledcWrite(pin, duty); \n}\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // PWM attach\n  ledcAttach(temp1Pin,     freq, resolution);\n  ledcAttach(humidity1Pin, freq, resolution);\n  ledcAttach(pressure1Pin, freq, resolution);\n  ledcAttach(wildfire1Pin, freq, resolution);\n\n  ledcAttach(temp2Pin,     freq, resolution);\n  ledcAttach(humidity2Pin, freq, resolution);\n  ledcAttach(pressure2Pin, freq, resolution);\n  ledcAttach(wildfire2Pin, freq, resolution);\n\n  // Start them OFF\n  ledcWrite(temp1Pin, 0);\n  ledcWrite(humidity1Pin, 0);\n  ledcWrite(pressure1Pin, 0);\n  ledcWrite(wildfire1Pin, 0);\n\n  ledcWrite(temp2Pin, 0);\n  ledcWrite(humidity2Pin, 0);\n  ledcWrite(pressure2Pin, 0);\n  ledcWrite(wildfire2Pin, 0);\n\n  WiFi.mode(WIFI_STA);\n  delay(200);\n\n  Serial.print(\"Receiver MAC: \");\n  printStaMac();\n\n  esp_wifi_set_channel(1, WIFI_SECOND_CHAN_NONE);\n\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error initializing ESP-NOW\");\n    while (true) delay(100);\n  }\n\n  if (esp_now_register_recv_cb(OnDataRecv) != ESP_OK) {\n    Serial.println(\"Error registering ESP-NOW receive callback\");\n    while (true) delay(100);\n  }\n\n  Serial.println(\"Receiver ready.\");\n}\n\nvoid loop() {\n  uint32_t now = millis();\n\n  // Copy volatile globals into locals\n  float tempC = latestTempC;\n  float hum   = latestHumidity_pct;\n  float pres  = latestPressure_hPa;\n\n  // - If temp &gt;= 40C -&gt; fade temp1 LED\n  if (!isnan(tempC) &amp;&amp; tempC &gt;= 30.0f) {\n    if (now - lastFadeStep1 &gt;= fadeIntervalMs) {\n      lastFadeStep1 = now;\n      stepFade(temp1Pin, duty1, dir1);\n    }\n  } else {\n    ledcWrite(temp1Pin, 0); // off when not alarming\n  }\n\n  // - If humidity &lt;= 20% -&gt; fade humidity1 LED\n  if (!isnan(hum) &amp;&amp; hum &lt;= 20.0f) {\n    if (now - lastFadeStep2 &gt;= fadeIntervalMs) {\n      lastFadeStep2 = now;\n      stepFade(humidity1Pin, duty2, dir2);\n    }\n  } else {\n    ledcWrite(humidity1Pin, 0);\n  }\n\n  // - If pressure &lt;= some threshold -&gt; fade pressure1 LED\n  if (!isnan(pres) &amp;&amp; pres &gt;= 960.0f) {\n    if (now - lastFadeStep3 &gt;= fadeIntervalMs) {\n      lastFadeStep3 = now;\n      stepFade(pressure1Pin, duty3, dir3);\n    }\n  } else {\n    ledcWrite(pressure1Pin, 0);\n  }\n\n  bool wildfireAlarm =\n    (!isnan(tempC) &amp;&amp; tempC &gt;= 30.0f &amp;&amp; !isnan(hum)  &amp;&amp; hum  &lt;= 20.0f) ||\n    (!isnan(tempC) &amp;&amp; tempC &gt;= 30.0f &amp;&amp; !isnan(pres) &amp;&amp; pres &gt;= 960.0f) ||\n    (!isnan(hum)   &amp;&amp; hum  &lt;= 20.0f &amp;&amp; !isnan(pres) &amp;&amp; pres &gt;= 960.0f);\n\n  if (wildfireAlarm) {\n    if (now - lastFadeStep4 &gt;= fadeIntervalMs) {\n      lastFadeStep4 = now;\n      stepFade(wildfire1Pin, duty4, dir4);\n    }\n  } else {\n    ledcWrite(wildfire1Pin, 0);\n  }\n\n\n  //to keep fade staying smooth\n  delay(1);\n}\n</code></pre>"},{"location":"project-resources/#weather-station-code-c","title":"Weather Station Code (C++)","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;Wire.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;esp_wifi.h&gt;\n#include &lt;esp_now.h&gt;\n\n#include &lt;Adafruit_Sensor.h&gt;\n#include &lt;Adafruit_BME280.h&gt;\n\n// ESP-NOW receiver MAC Address (control panel)\nuint8_t receiverAddress[] = {0x48, 0xCA, 0x43, 0x4E, 0x59, 0x90}; // receiver MAC\n\n// I2C pins\nstatic constexpr int I2C_SDA = 8;\nstatic constexpr int I2C_SCL = 9;\n\n// BME280 object\nAdafruit_BME280 bme;              // I2C\nstatic constexpr uint8_t BME_ADDR = 0x76;  // SDO grounded -&gt; 0x76\n\n// data payload\ntypedef struct __attribute__((packed)) {\n  float tempC;          // degrees C\n  float pressure_hPa;   // hPa\n  float humidity_pct;   // %RH\n  uint32_t timestamp_ms;\n} telemetry_struct;\n\ntelemetry_struct myData;\n\n//callback for ESP-NOW\nvoid onDataSent(const wifi_tx_info_t *tx_info, esp_now_send_status_t status) {\n  Serial.print(\"ESP-NOW send status: \");\n  Serial.println(status == ESP_NOW_SEND_SUCCESS ? \"SUCCESS\" : \"FAIL\");\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(200);\n\n  //I2C initializing\n  Wire.begin(I2C_SDA, I2C_SCL);\n  Wire.setClock(100000);  // safe for BME280\n\n  //BME280 initializing\n  bool ok = bme.begin(BME_ADDR);\n  if (!ok) {\n    //check other board address\n    ok = bme.begin(0x77);\n  }\n  if (!ok) {\n    Serial.println(\"BME280 not found at 0x76 or 0x77. Check wiring/power!\");\n    while (true) delay(100);\n  }\n  Serial.println(\"BME280 found.\");\n\n  //ESP-NOW initialize\n  WiFi.mode(WIFI_STA);\n\n  //set wifi channel to 1\n  esp_wifi_set_channel(1, WIFI_SECOND_CHAN_NONE);\n\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error initializing ESP-NOW\");\n    while (true) delay(100);\n  }\n\n  esp_now_register_send_cb(onDataSent);\n\n  esp_now_peer_info_t peerInfo = {};\n  memcpy(peerInfo.peer_addr, receiverAddress, sizeof(receiverAddress));\n  peerInfo.channel = 1;\n  peerInfo.ifidx = WIFI_IF_STA;\n  peerInfo.encrypt = false;\n\n  if (esp_now_add_peer(&amp;peerInfo) != ESP_OK) {\n    Serial.println(\"Failed to add peer\");\n    while (true) delay(100);\n  }\n\n  Serial.println(\"Sender ready.\");\n}\n\nvoid loop() {\n  // Read BME280\n  float tempC = bme.readTemperature();             // \u00b0C\n  float pressure_hPa = bme.readPressure() / 100.0; // Pa -&gt; hPa\n  float humidity = bme.readHumidity();             // %\n\n  // Basic sanity check for sensor wiring\n  if (isnan(tempC) || isnan(pressure_hPa) || isnan(humidity)) {\n    Serial.println(\"BME280 read returned NaN (check sensor/wiring).\");\n    delay(1000);\n    return;\n  }\n\n  myData.tempC = tempC;\n  myData.pressure_hPa = pressure_hPa;\n  myData.humidity_pct = humidity;\n  myData.timestamp_ms = millis();\n\n  Serial.printf(\"T=%.2f C, P=%.2f hPa, H=%.2f %% -&gt; sending...\\n\",\n                tempC, pressure_hPa, humidity);\n\n  esp_err_t result = esp_now_send(receiverAddress, (uint8_t*)&amp;myData, sizeof(myData));\n  if (result == ESP_OK) Serial.println(\"Sent OK\");\n  else Serial.println(\"ESP-NOW send error\");\n\n  delay(2000);\n}\n</code></pre>"},{"location":"reflection/","title":"Reflection","text":""},{"location":"reflection/#lessons-learned","title":"Lessons Learned","text":"<ol> <li> <p>Research as much as possible </p> <p>Researching as much as possible will decrease the build and integration time significantly. By ensuring all circuits are accurate and all components are rated to work together, there will be less debugging errors that pop up, thereby allowing the project to be completed quicker. </p> </li> <li> <p>Verify the right components were soldered </p> <p>Sometimes the simplest mistake is the one that is usually made. If two different voltage regulators are in the project components, ensure that the right voltage regulator is used for it's respective circuit components. This was the reason why the voltage regulator system was not working on the control panel board during the first test. </p> </li> <li> <p>Get large surface mount components </p> <p>The college you are in will not always have the best or precise lab equipment. Furthermore, small surface mount components are extremely hard to hand solder if you have no prior experience. Make life easier for yourself and use large surface mount components, as the risk of shorting any pins is very low. </p> </li> <li> <p>Don't just check the datasheet, verify the datasheet</p> <p>Often times, the datasheet does not include all important information pertaining to your component. Look for additional advice on the internet from other people, whether it be forums or YouTube tutorials. The ESP32-S3-WROOM-1 datasheet did not specify that the boot pin needs a pullup resistor. The state of the boot pin is CRITICAL in executing logic. This likely prevented two of our microcontroller boards from working. </p> </li> <li> <p>Be cautious and think ahead</p> <p>Always have a back up plan for critical systems. The datasheet did not say that the built in USB compiler within the ESP32-S3 chip ONLY works if there is code in the ESP32-S3 chip. But a freshly bought chip has no code in it, so it was impossible to first program the chips with the USB connector, as initially planned. Having the snap programmer as a back up plan to program the board was critical in this project's success. </p> </li> <li> <p>Focus on minimum viable product first </p> <p>With engineers, there is a tendency to dream up grand projects with complex functions. Start with the bare minimum first, as it will satisfy your stakeholders but also save yourself from a headache. Once the bare minimum has been accomplished, then build upon it. </p> </li> <li> <p>Integrate each code section one at a time </p> <p>When integrating multiple components' logic together, start with one component at a time. That way, if multiple components have issues in them, you'll spot their errors one at a time, which can be less overwhelming than seeing multiple errors all at once. </p> </li> <li> <p>Don't hand solder SMD components on an empty stomach</p> <p>An empty stomach produces shaky hands and a less intelligent brain. Soldering SMD components is much easier if your hands are steady. </p> </li> <li> <p>Connect all of your MCU's GPIOs to male/female header pins </p> <p>When hand soldering your MCU, it is possible that you can short two important pins together. Sometimes, it is impossible to figure out how they shorted. By connectiong all of your MCU's GPIOs to pins that jumper wires can connect to, it gives your project flexibility. </p> </li> <li> <p>Buy plenty of microcontroller chips </p> <p>Microcontroller chips can be finicky, especially the ESP32 ones. Buying plenty of microcontroller chips ensures you are covered if some of them don't work. This is partially the reason why Project Firesight only had one weather station board working, as the rest of the ESP32 chips would not execute their program. </p> </li> </ol>"},{"location":"reflection/#top-5-recommendations-for-future-students","title":"Top 5 Recommendations for Future Students","text":"<ol> <li> <p>Research your circuits and your components as much as possible. This reduces the amount of errors that pop up later in the project. </p> </li> <li> <p>Practice surface mount soldering. Everything becomes better with practice, and it is important to solder your components correctly to ensure your project functions as intended. </p> </li> <li> <p>Get large surface mount components. The project can satisfy grade requirements while also being easier to solder. </p> </li> <li> <p>Practice desoldering components. It is likely that mistakes will be made when hand soldering, so another important skill is knowing how to desolder. It will also save you time and frustration if you can quickly fix a short. </p> </li> <li> <p>Pay attention to detail when soldering your boards. The components can look very similar to each other, and mistakes can happen. Soldering your circuits correctly will decrease debugging time. </p> </li> </ol>"},{"location":"reflection/#version-20","title":"Version 2.0","text":""},{"location":"reflection/#communication-architecture","title":"Communication Architecture","text":"<p>The communication architecture could be improved by adding an acknowledgement from the control panel that it successfully received the wireless data. This could be done by creating a helper function in the control panel code, which would send a string back to the weather station. The weather station would have a helper function to decode the received acknowledgement, which would light up an extra LED when it receives an acknowledgement. This would give a visual indicator when the weather stations are successfully connected to the control panel. </p> <p>The communication architecture could also be improved by using ESP-MESH. This wireless communication protocol is specifically designed to work with a network of devices. While ESP-NOW can accomplish this, it requires more lines of code than ESP-MESH. </p>"},{"location":"reflection/#hardware","title":"Hardware","text":"<p>For version 2.0 of the hardware design, more silkscreen comments would be added to further increase the clarity of the board when making connections to other hardware components or during soldering. This is an important change as it would decrease the time it would take for soldering and testing, and also ensures that no wrong connections are made that could harm the components on the board. Version 2.0 of Project Firesight would have a casing for the control panel such that the bare PCB is not exposed. This would increase the longevity of the product and protect critical components. In addition, all GPIO pins on the microcontroller for both boards would be connected to male header pins, which would provide flexibility during project integration if the initially planned pins were shorted during soldering. Lastly, version 2.0 would use surface mount components that have pins extending from the SIDE of the component, not copper pads on the back. This would make hand-soldering much easier and prevent accidental shorts (which is what happened with our motor driver). </p>"},{"location":"team-schematic/","title":"Final Schematic and PCB","text":"<p>The EDA software used for this project was KiCad. The team schematic and PCBs are split into two -- one for the main control panel and one for the weather stations.</p> <p>The KiCad project file zip can be downloaded by this link: KiCad Projects File</p> <p>The Gerber Drill files zip can be downloaded by this link: KiCad Gerber File</p>"},{"location":"team-schematic/#schematic","title":"Schematic","text":""},{"location":"team-schematic/#main-control-panel-circuit","title":"Main Control Panel Circuit","text":"<p>Figure 1: Control Panel Schematic</p> <p></p>"},{"location":"team-schematic/#weather-station-circuit","title":"Weather Station Circuit","text":"<p>Figure 2: Weather Station Schematic</p> <p></p> <p>The schematic satisfies the user needs of the project as the power regulator circuit supplies +3.3V to all required power pins for all components in the weather station &amp; control panel schematic. The product won't function as intended if it doesn't receive any power. The microcontroller for both schematics can be programmed either through the USB D- and D+ lines or through the snap programmer, in case any of the two options fail. This satisfies user needs as it provides the logic for the product, which allows for the transmission of real-time environmental data through wireless communication. For the control panel, the logic will indicate what areas are susceptible to wildfires, which enables proactive wildfire supression. </p>"},{"location":"team-schematic/#schematic-design-decision-making-process","title":"Schematic Design &amp; Decision Making Process","text":"<p>The schematic was designed to be as readable and simple as possible. Net labels were used to clean up schematic connections and improve readability. Subsystems were split into different areas on the schematic for organization, and text was placed where needed to add clarity.  </p>"},{"location":"team-schematic/#pcb-design","title":"PCB Design","text":""},{"location":"team-schematic/#control-panel-pcb","title":"Control Panel PCB","text":"<p>Figure 3: Front Copper Layer - Control Panel</p> <p></p> <p>Figure 4: Back Copper Layer - Control Panel </p> <p></p>"},{"location":"team-schematic/#weather-station-pcb","title":"Weather Station PCB","text":"<p>Figure 5: Front Copper Layer - Weather Station </p> <p></p> <p>Figure 6: Back Copper Layer - Weather Station</p> <p> </p>"},{"location":"team-schematic/#pcb-design-decision-making-process","title":"PCB Design &amp; Decision Making Process","text":"<p>The PCB design process aimed for simplicity and to keep subsystems near each other as much as possible. Components were organized onto the board first before connections were made. All boards utilize two layers, a front copper layer as the positive power plane and a back copper layer as the ground power plane. This was done to decrease the amount of connections on the board and increase simplicity. Silkscreen text was added to increase clarity when soldering. </p>"},{"location":"team-schematic/#version-20","title":"Version 2.0","text":"<p>For version 2.0 of the hardware design, more silkscreen comments would be added to further increase the clarity of the board when making connections to other hardware components or during soldering. This is an important change as it would decrease the time it would take for soldering and testing, and also ensures that no wrong connections are made that could harm the components on the board. Version 2.0 of Project Firesight would have a casing for the control panel such that the bare PCB is not exposed. This would increase the longevity of the product and protect critical components. In addition, all GPIO pins on the microcontroller for both boards would be connected to male header pins, which would provide flexibility during project integration if the initially planned pins were shorted during soldering. Lastly, version 2.0 would use surface mount components that have pins extending from the SIDE of the component, not copper pads on the back. This would make hand-soldering much easier and prevent accidental shorts (which is what happened with our motor driver). </p>"},{"location":"teamorg/","title":"Team Organization","text":"<p>The team organization outlines team goals, team charter, and the product mission statement</p>"},{"location":"teamorg/#team-goals","title":"Team Goals","text":"<p>Team goals were determined through discussion, in which the common goals were highlighted and chosen. Below are a selection of the team goals common amongst all of the members. For a detailed list of all team goals, please see the Team Organization Appendix. </p> <ul> <li> <p>Create a product that allows our stakeholders to PROACTIVELY fight wildfires, particularly through multiple mini-weather stations that send data back to a control panel. </p> </li> <li> <p>Successfully integrate wireless data communication into the final product</p> </li> <li> <p>Create at least two mini weather stations that successfully send data back to the control panel. </p> </li> <li> <p>Accurately depict a wildfire susceptible area by measuring at least three different wildfire causing variables</p> </li> <li> <p>Create a product that operates and runs successfully for at least three months while staying under the $300 budget</p> </li> <li> <p>Successfully integrate at least four subsystems together</p> </li> <li> <p>Create a product that can withstand temperatures up to 1500 degrees Fahrenheit</p> </li> <li> <p>Create a product that withstands wind gusts up to 120 miles per hour</p> </li> <li> <p>Create a product that blends in with the evnironment to prevent wildlife engagement</p> </li> <li> <p>Create a product that does not interfere with the environment, ecosystem, or any local, state, and federal rules and regulations</p> </li> </ul> <p>These goals were determined by the information presented at the stakeholder interview, and was further refined during discussions in class and in team meetings. As the stakeholder conducts only a reactive approach to fighting wildfires, Team Embermen is focused on developing a proactive approach. In this way, the stakeholder can predict potential wildfire spots before they happen, thereby increasing their wildfire detection efficiency.  </p> <p>These goals will help Team Embermen in academia and in industry, as it further develops technical, project management, and teammwork skills, all of which are important in the work force and future academic pursuits. </p>"},{"location":"teamorg/#team-charter","title":"Team Charter","text":"<p>The team charter is a summary statement of the project goals, which was determined after discussion with the stakeholders, professor &amp; TA's, and internal team discussions.</p> <p>Team Embermen will design and build a cost-effective mini weather station network for the Arizona Department of Forestry and Wildfire Management. The system will consist of at least two wireless, sensor-equipped stations integrated with a central control panel to identify wildfire-susceptible areas and support proactive suppression. Operating for at least three months on a $300 budget, the product will integrate at least four subsystems, withstand extreme conditions (1500\u00b0F, 120 mph winds), and remain environmentally compliant while blending into natural surroundings.</p>"},{"location":"teamorg/#product-mission-statement","title":"Product Mission Statement","text":"<p>The product mission statement details the purpose and direction of Project Firesight, which was determined through discussion with the stakeholders, professors &amp; TA's, and multiple internal team discussions. </p> <p>The mission of Project Firesight is to design, build, debug, and test a wireless weather station network for the State of Arizona's Department of Forestry and Wildfire Management, with the purpose of predicting susceptible wildfire areas to proactively improve wildfire detection &amp; suppression, thereby decreasing wildfire suppression time.</p>"},{"location":"appendix/","title":"Appendix","text":""},{"location":"appendix/#subsystem-split","title":"Subsystem Split","text":"<p>The workload for Project Firesight was divided into four subsystems that will be distributed evenly amongst the four teammates. These four subsystems are Mechanical Casing/Structures (including the underground feature) &amp; Microcontroller, ESP-NOW Communication, Power Supply, and Control Panel. The sensor subsystem was removed due to the responsible teammate withdrawing from the course. As such, an already built BME280 breakout board was used in replacement. The weather stations will be communicating with the main control panel continuously. </p>"},{"location":"appendix/#idea-generation-sort-rank-recombine-group","title":"Idea Generation - Sort, Rank, Recombine, Group","text":"<p>The brainstorming process generated a total of 120 ideas. During the process, no idea was dismissed in order to encourage creative thinking. The ideas generated ranged from the type of sensors to use, how to use them, how the system will function, etc. The figure below depicts all of the ideas generated during this process. </p> <p></p> <p>Afterwards, the generated ideas were sorted based on similar themes. The themes chosen were Life Cycle, Sensors/Data, Structure/Ergonomics, Communication, Prevention, and Response. The figure below depicts all of the ideas after being sorted. The 'Life Cycle' grouping is not shown due to issues with image size.</p> <p></p> <p>The ideas were then ranked based on how feasible they are, which was determined by budget constraints, time constraints, and if they satisfied the stakeholder needs (durability, survivability, and wireless real-time data). The figure below depicts the ranked ideas, which have a 'fire' emoji on them. </p> <p></p> <p>Afterwards, the ranked ideas were improved upon, recombined, and finally grouped into our final product: a wireless weather station with a LED control panel, with an HMI screen attached as a stretch goal. The figure below depicts the final grouping. </p> <p></p>"},{"location":"appendix/01_subpage/","title":"Team Organization Appendix","text":""},{"location":"appendix/01_subpage/#team-goals","title":"Team Goals","text":"<ul> <li> <p>Further enhance the technical and project management skills developed in the previous course, EGR304</p> </li> <li> <p>Further enhance and develop a basic understanding of the product development process</p> </li> <li> <p>Gain an intermediary mastery of creating an electromechanical system</p> </li> <li> <p>Create a product that allows our stakeholders to PROACTIVELY fight wildfires, particularly through multiple mini-weather stations that send data back to a control panel. </p> </li> <li> <p>Successfully integrate wireless data communication into the final product</p> </li> <li> <p>Create at least two mini weather stations that successfully send data back to the control panel. </p> </li> <li> <p>Accurately depict a wildfire susceptible area by measuring at least three different wildfire causing variables</p> </li> <li> <p>Create a product that operates and runs successfully for at least three months while staying under the $300 budget</p> </li> <li> <p>Successfully integrate at least four subsystems with the main control panel</p> </li> <li> <p>Create a product that can withstand temperatures up to 1500 degrees Fahrenheit</p> </li> <li> <p>Create a product that withstands wind gusts up to 120 miles per hour</p> </li> <li> <p>Create a product that blends in with the evnironment to prevent wildlife engagement</p> </li> <li> <p>Create a product that does not interfere with the environment, ecosystem, or any local, state, and federal rules and regulations</p> </li> </ul>"},{"location":"appendix/02_subpage/","title":"ESP32 C++ Code Appendix","text":""},{"location":"appendix/02_subpage/#control-panel-code-c","title":"Control Panel Code (C++)","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;esp_now.h&gt;\n#include &lt;esp_wifi.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n\n//LED Pins\nconst int temp1Pin     = 4;\nconst int humidity1Pin = 5;\nconst int pressure1Pin = 6;\nconst int wildfire1Pin = 7;\n\nconst int temp2Pin     = 9;\nconst int humidity2Pin = 10;\nconst int pressure2Pin = 11;\nconst int wildfire2Pin = 12;\n\n//PWM settings\nconst int freq = 5000;\nconst int resolution = 8;   // 0-255\n\n//Fade state\nint duty1 = 0, dir1 = +1;\nint duty2 = 0, dir2 = +1;\nint duty3 = 0, dir3 = +1;\nint duty4 = 0, dir4 = +1;\n\nconst uint32_t fadeIntervalMs = 15;\nconst int fadeSize = 5;\n\nuint32_t lastFadeStep1 = 0;\nuint32_t lastFadeStep2 = 0;\nuint32_t lastFadeStep3 = 0;\nuint32_t lastFadeStep4 = 0;\n\n// data payload\ntypedef struct __attribute__((packed)) {\n  float    tempC;         // \u00b0C\n  float    pressure_hPa;  // hPa\n  float    humidity_pct;  // %RH\n  uint32_t timestamp_ms;  // sender millis()\n} telemetry_struct;\n\ntelemetry_struct receivedData;\n\n// Latest readings accessible from loop()\nvolatile float latestTempC = NAN;\nvolatile float latestPressure_hPa = NAN;\nvolatile float latestHumidity_pct = NAN;\nvolatile uint32_t latestTimestamp = 0;\n\nbool wildfireActive = false; \n\nstatic void printMACAddress(const uint8_t *mac) {\n  Serial.printf(\"%02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n}\n\nstatic void printStaMac() {\n  uint8_t mac[6];\n  esp_wifi_get_mac(WIFI_IF_STA, mac);\n  Serial.printf(\"%02X:%02X:%02X:%02X:%02X:%02X\\n\",\n                mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n}\n\n// ESP-NOW receive callback\nvoid OnDataRecv(const esp_now_recv_info_t *info, const uint8_t *incomingData, int len) {\n  if (len != (int)sizeof(telemetry_struct)) {\n    Serial.printf(\"Received %d bytes (expected %d). Ignoring.\\n\",\n                  len, (int)sizeof(telemetry_struct));\n    return;\n  }\n\n  memcpy(&amp;receivedData, incomingData, sizeof(receivedData));\n\n  // Update \"latest\" globals\n  latestTempC = receivedData.tempC;\n  latestPressure_hPa = receivedData.pressure_hPa;\n  latestHumidity_pct = receivedData.humidity_pct;\n  latestTimestamp = receivedData.timestamp_ms;\n\n  Serial.print(\"From: \");\n  printMACAddress(info-&gt;src_addr);\n\n  Serial.printf(\"Temp: %.2f C, Pressure: %.2f hPa, Humidity: %.2f %% | timestamp_ms: %lu\\n\\n\",\n                receivedData.tempC,\n                receivedData.pressure_hPa,\n                receivedData.humidity_pct,\n                (unsigned long)receivedData.timestamp_ms);\n}\n\nstatic void stepFade(int pin, int &amp;duty, int &amp;dir) {\n  duty += dir * fadeSize;\n  if (duty &gt;= 255) { duty = 255; dir = -1; }\n  if (duty &lt;= 0)   { duty = 0;   dir = +1; }\n  ledcWrite(pin, duty); \n}\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // PWM attach\n  ledcAttach(temp1Pin,     freq, resolution);\n  ledcAttach(humidity1Pin, freq, resolution);\n  ledcAttach(pressure1Pin, freq, resolution);\n  ledcAttach(wildfire1Pin, freq, resolution);\n\n  ledcAttach(temp2Pin,     freq, resolution);\n  ledcAttach(humidity2Pin, freq, resolution);\n  ledcAttach(pressure2Pin, freq, resolution);\n  ledcAttach(wildfire2Pin, freq, resolution);\n\n  // Start them OFF\n  ledcWrite(temp1Pin, 0);\n  ledcWrite(humidity1Pin, 0);\n  ledcWrite(pressure1Pin, 0);\n  ledcWrite(wildfire1Pin, 0);\n\n  ledcWrite(temp2Pin, 0);\n  ledcWrite(humidity2Pin, 0);\n  ledcWrite(pressure2Pin, 0);\n  ledcWrite(wildfire2Pin, 0);\n\n  WiFi.mode(WIFI_STA);\n  delay(200);\n\n  Serial.print(\"Receiver MAC: \");\n  printStaMac();\n\n  esp_wifi_set_channel(1, WIFI_SECOND_CHAN_NONE);\n\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error initializing ESP-NOW\");\n    while (true) delay(100);\n  }\n\n  if (esp_now_register_recv_cb(OnDataRecv) != ESP_OK) {\n    Serial.println(\"Error registering ESP-NOW receive callback\");\n    while (true) delay(100);\n  }\n\n  Serial.println(\"Receiver ready.\");\n}\n\nvoid loop() {\n  uint32_t now = millis();\n\n  // Copy volatile globals into locals\n  float tempC = latestTempC;\n  float hum   = latestHumidity_pct;\n  float pres  = latestPressure_hPa;\n\n  // - If temp &gt;= 40C -&gt; fade temp1 LED\n  if (!isnan(tempC) &amp;&amp; tempC &gt;= 30.0f) {\n    if (now - lastFadeStep1 &gt;= fadeIntervalMs) {\n      lastFadeStep1 = now;\n      stepFade(temp1Pin, duty1, dir1);\n    }\n  } else {\n    ledcWrite(temp1Pin, 0); // off when not alarming\n  }\n\n  // - If humidity &lt;= 20% -&gt; fade humidity1 LED\n  if (!isnan(hum) &amp;&amp; hum &lt;= 20.0f) {\n    if (now - lastFadeStep2 &gt;= fadeIntervalMs) {\n      lastFadeStep2 = now;\n      stepFade(humidity1Pin, duty2, dir2);\n    }\n  } else {\n    ledcWrite(humidity1Pin, 0);\n  }\n\n  // - If pressure &lt;= some threshold -&gt; fade pressure1 LED\n  if (!isnan(pres) &amp;&amp; pres &gt;= 960.0f) {\n    if (now - lastFadeStep3 &gt;= fadeIntervalMs) {\n      lastFadeStep3 = now;\n      stepFade(pressure1Pin, duty3, dir3);\n    }\n  } else {\n    ledcWrite(pressure1Pin, 0);\n  }\n\n  bool wildfireAlarm =\n    (!isnan(tempC) &amp;&amp; tempC &gt;= 30.0f &amp;&amp; !isnan(hum)  &amp;&amp; hum  &lt;= 20.0f) ||\n    (!isnan(tempC) &amp;&amp; tempC &gt;= 30.0f &amp;&amp; !isnan(pres) &amp;&amp; pres &gt;= 960.0f) ||\n    (!isnan(hum)   &amp;&amp; hum  &lt;= 20.0f &amp;&amp; !isnan(pres) &amp;&amp; pres &gt;= 960.0f);\n\n  if (wildfireAlarm) {\n    if (now - lastFadeStep4 &gt;= fadeIntervalMs) {\n      lastFadeStep4 = now;\n      stepFade(wildfire1Pin, duty4, dir4);\n    }\n  } else {\n    ledcWrite(wildfire1Pin, 0);\n  }\n\n\n  //to keep fade staying smooth\n  delay(1);\n}\n</code></pre>"},{"location":"appendix/02_subpage/#weather-station-code-c","title":"Weather Station Code (C++)","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;Wire.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;esp_wifi.h&gt;\n#include &lt;esp_now.h&gt;\n\n#include &lt;Adafruit_Sensor.h&gt;\n#include &lt;Adafruit_BME280.h&gt;\n\n// ESP-NOW receiver MAC Address (control panel)\nuint8_t receiverAddress[] = {0x48, 0xCA, 0x43, 0x4E, 0x59, 0x90}; // receiver MAC\n\n// I2C pins\nstatic constexpr int I2C_SDA = 8;\nstatic constexpr int I2C_SCL = 9;\n\n// BME280 object\nAdafruit_BME280 bme;              // I2C\nstatic constexpr uint8_t BME_ADDR = 0x76;  // SDO grounded -&gt; 0x76\n\n// data payload\ntypedef struct __attribute__((packed)) {\n  float tempC;          // degrees C\n  float pressure_hPa;   // hPa\n  float humidity_pct;   // %RH\n  uint32_t timestamp_ms;\n} telemetry_struct;\n\ntelemetry_struct myData;\n\n//callback for ESP-NOW\nvoid onDataSent(const wifi_tx_info_t *tx_info, esp_now_send_status_t status) {\n  Serial.print(\"ESP-NOW send status: \");\n  Serial.println(status == ESP_NOW_SEND_SUCCESS ? \"SUCCESS\" : \"FAIL\");\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(200);\n\n  //I2C initializing\n  Wire.begin(I2C_SDA, I2C_SCL);\n  Wire.setClock(100000);  // safe for BME280\n\n  //BME280 initializing\n  bool ok = bme.begin(BME_ADDR);\n  if (!ok) {\n    //check other board address\n    ok = bme.begin(0x77);\n  }\n  if (!ok) {\n    Serial.println(\"BME280 not found at 0x76 or 0x77. Check wiring/power!\");\n    while (true) delay(100);\n  }\n  Serial.println(\"BME280 found.\");\n\n  //ESP-NOW initialize\n  WiFi.mode(WIFI_STA);\n\n  //set wifi channel to 1\n  esp_wifi_set_channel(1, WIFI_SECOND_CHAN_NONE);\n\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error initializing ESP-NOW\");\n    while (true) delay(100);\n  }\n\n  esp_now_register_send_cb(onDataSent);\n\n  esp_now_peer_info_t peerInfo = {};\n  memcpy(peerInfo.peer_addr, receiverAddress, sizeof(receiverAddress));\n  peerInfo.channel = 1;\n  peerInfo.ifidx = WIFI_IF_STA;\n  peerInfo.encrypt = false;\n\n  if (esp_now_add_peer(&amp;peerInfo) != ESP_OK) {\n    Serial.println(\"Failed to add peer\");\n    while (true) delay(100);\n  }\n\n  Serial.println(\"Sender ready.\");\n}\n\nvoid loop() {\n  // Read BME280\n  float tempC = bme.readTemperature();             // \u00b0C\n  float pressure_hPa = bme.readPressure() / 100.0; // Pa -&gt; hPa\n  float humidity = bme.readHumidity();             // %\n\n  // Basic sanity check for sensor wiring\n  if (isnan(tempC) || isnan(pressure_hPa) || isnan(humidity)) {\n    Serial.println(\"BME280 read returned NaN (check sensor/wiring).\");\n    delay(1000);\n    return;\n  }\n\n  myData.tempC = tempC;\n  myData.pressure_hPa = pressure_hPa;\n  myData.humidity_pct = humidity;\n  myData.timestamp_ms = millis();\n\n  Serial.printf(\"T=%.2f C, P=%.2f hPa, H=%.2f %% -&gt; sending...\\n\",\n                tempC, pressure_hPa, humidity);\n\n  esp_err_t result = esp_now_send(receiverAddress, (uint8_t*)&amp;myData, sizeof(myData));\n  if (result == ESP_OK) Serial.println(\"Sent OK\");\n  else Serial.println(\"ESP-NOW send error\");\n\n  delay(2000);\n}\n</code></pre>"},{"location":"component_selection/","title":"Component Selection","text":""},{"location":"component_selection/#subsystem-1-power","title":"Subsystem 1: Power","text":"<p>Table 1: Power Component Selection</p>"},{"location":"component_selection/#bucking-voltage-regulator","title":"Bucking Voltage Regulator","text":"<ol> <li> <p>LM2575M-3.3 Bucking Voltage Regulator</p> <p></p> <ul> <li>$0.94/each</li> <li>Product Link</li> </ul> Pros Cons Relatively solder friendly Generates switching noise ripple No heat sink required in some designs Limited to 1A output Efficiency drops under light loads </li> <li> <p>LM7805MPX/NOPB Bucking Voltage Regulator</p> <p></p> <ul> <li>$1.43/each</li> <li>Product Link</li> </ul> Pros Cons Very low noise output Poor efficiency at high voltages Doesn't require many external components Limited to 1A output Widely available and inexpensive </li> <li> <p>LM2596S-(5.0/3.3V)/NOPB Bucking Voltage Regulator</p> <p></p> <ul> <li>$6.97/each</li> <li>Product Link</li> </ul> Pros Cons High efficiency at moderate to high current Generates switching noise Has a shutdown feature Feedback trace must be isolated Widely used, readily available reference designs May be difficult to solder </li> </ol> <p>Choice: LM2596S-(5.0/3.3V)/NOPB Bucking Voltage Regulator</p> <p>Rationale: The best choice is the LM2596S/NOPB for 5V output and 3.3V as it has a high efficiency at a much higher current load (3A), incorporates a shutdown feature, and is widely used with available reference designs. The high current load is better suited for our project as we will be using a small DC motor to close the underground PCB box in the event of extreme weather conditions. Furthermore, the shutdown feature can be used to turn off all critical components in the event that the underground PCB box must close.</p>"},{"location":"component_selection/#subsystem-2-sensors","title":"Subsystem 2: Sensors","text":"<p>Table 2: Sensor Component Selection</p>"},{"location":"component_selection/#atmospheric-sensors","title":"Atmospheric Sensors","text":"<ol> <li> <p>BME 280 - Humidity, Temperature, and Pressure Sensor</p> <p></p> <ul> <li>$4.03/each</li> <li>Product Link</li> </ul> Pros Cons Low power consumption Sensitive to harsh weather Senses 3 data types More complex coding API library available for use on github </li> <li> <p>AMG8833-Temperature IR Sensor</p> <p></p> <ul> <li>$1.43/each</li> <li>Product Link</li> </ul> Pros Cons Very low noise output Poor efficiency at high voltages Doesn't require many external components Limited to 1A output Widely available and inexpensive </li> <li> <p>SHT31-DIS-B2.5KS - Humidity &amp; Temperature Sensor</p> <p></p> <ul> <li>$4.01/each</li> <li>Product Link</li> </ul> Pros Cons Two distinctive, user selectable I2C addresses Generates switching noise Wide input voltage range Feedback trace must be isolated NIST traceable measurements (industry standard) May be difficult to solder </li> </ol> <p>Choice: BME 280 - Humidity, Temperature, and Pressure Sensor</p> <p>Rationale: The best choice for this subsystem is the BME 280 as it senses multiple variables within one package, which prevents I2C bus problems. The code is intensive, but an API library is available on github and the datasheet offers code examples to follow.  </p>"},{"location":"component_selection/#subsystem-3-control-panel","title":"Subsystem 3: Control Panel","text":"<p>Table 3: Red LED Component Selection</p>"},{"location":"component_selection/#wildfire-susceptibilite-indicating-led","title":"Wildfire Susceptibilite Indicating LED","text":"<ol> <li> <p>HLMP-Q150-F0011 Red LED</p> <p></p> <ul> <li>$2.01/each</li> <li>Product Link</li> </ul> Pros Cons Easiest to solder Expensive High visibility Takes up space Heat resistant </li> <li> <p>SML-D12U1WT86 LED</p> <p></p> <ul> <li>$0.12/each</li> <li>Product Link</li> </ul> Pros Cons Inexpensive Vulnerable to thermal cycling Compact Difficult to solder Very bright for its size </li> <li> <p>APT2012SURCK LED</p> <p></p> <ul> <li>$0.20/each</li> <li>Product Link</li> </ul> Pros Cons Low power consumption Difficult to solder Small footprint Fragile Vibrant red, suitable for status indication </li> </ol> <p>Choice: HLMP-Q150-F0011 Red LED</p> <p>Rationale: Option 1 is the best choice for our design because it\u2019s the least fragile and easiest to manually solder of the 3. Furthermore, having the highest visibility possible is important for warning the user of wildfire susceptibility.</p> <p>Table 4: Sensor LED Component Selection</p>"},{"location":"component_selection/#sensor-threshold-leds","title":"Sensor Threshold LEDs","text":"<ol> <li> <p>XL-1606UBC LED</p> <p></p> <ul> <li>$0.01042/each</li> <li>Product Link</li> </ul> Pros Cons Inexpensive Difficult to solder by hand Compact footprint Lower visibility Low power consumption </li> <li> <p>ALMD-CB1E-VW002 LED</p> <p></p> <ul> <li>$1.20/each</li> <li>Product Link</li> </ul> Pros Cons Low power consumption Takes up space Fast switching speed Limited viewing angle High brightness </li> <li> <p>150141RB73100 RGB LED</p> <p></p> <ul> <li>$0.34/each</li> <li>Product Link</li> </ul> Pros Cons RGB LED Thermal management complications Compact Requires multiple control channels Vibrant red, suitable for status indication </li> </ol> <p>Choice: ALMD-CB1E-VW002 Blue LED</p> <p>Rationale: Option 2 is the best choice for sensor threshold indication (humidity, temperature, wind direction) because of its low power consumption and high visibility. Furthermore, the RGB function of option 3 would go unused, making the further subsystem design complications unnecessary.</p>"},{"location":"component_selection/#subsystem-4-mechanical-casing-inner-casing-temperature","title":"Subsystem 4: Mechanical Casing &amp; Inner Casing Temperature","text":"<p>Table 5: Mechanical Casing Selection</p>"},{"location":"component_selection/#mechanical-casing","title":"Mechanical Casing","text":"<ol> <li> <p>High-grade ABS material</p> <p></p> <ul> <li>$49.99/each</li> <li>Product Link</li> </ul> Pros Cons Weatherproof &amp; waterproof Not fireproof Mounting panel included for easy PCB installation Not lightning proof Lightweight </li> <li> <p>Diecast Aluminum</p> <p></p> <ul> <li>$43.29/each</li> <li>Product Link</li> </ul> Pros Cons IP66 Rated Heavy IP66 Gasket included Hard to modify/drill into Powder Coated Black Not fireproof </li> <li> <p>Fireproof Box</p> <p></p> <ul> <li>$42.50/each</li> <li>Product Link</li> </ul> Pros Cons Fireproof Expensive Waterproof Heavy Durable Thick walls </li> </ol> <p>Choice: High-grade ABS </p> <p>Rationale: The high-grade ABS will be the best material and composition as it is waterproof to help with groundwater. Furthermore, it already has a PCB mounting method and it is easy to drill into to add our external sensors. Some people would argue that this is not the best option because it is not fireproof. This problem is solved by burying the box at least 1 foot underground. This will keep our electronics safe in the event of a wildfire.</p> <p>Table 6: Inner Casing Temperature Sensor Selection</p>"},{"location":"component_selection/#inner-casing-temperature-sensor","title":"Inner Casing Temperature Sensor","text":"<ol> <li> <p>TC74A4-3.3VCTTR Temperature Sensor</p> <p></p> <ul> <li>$1.15/each</li> <li>Product Link</li> </ul> Pros Cons Cheap Fragile Fairly accurate error margin up to 3 degrees Fairly simple to solder </li> <li> <p>SLTM20W87F Temperature Sensor</p> <p></p> <ul> <li>$0.76/each</li> <li>Product Link</li> </ul> Pros Cons Cheap Fragile Measures up to 130 degrees Celsius Older I2C timing Easy to solder Slow temperature updates </li> <li> <p>AS6218-AWLT-L Temperature Sensor</p> <p></p> <ul> <li>$1.09/each</li> <li>Product Link</li> </ul> Pros Cons Measures up to 125 degrees Celsius Fragile Accurate up to 0.8 degrees Celsius Could be hard to solder Can mount straight to PCB </li> </ol> <p>Choice: TC74A4-3.3VCTTR Temperature Sensor </p> <p>Rationale: The component we are going with is the TC74 because we have stock of this sensor and will not cost us to use. It will meet all the requirements needed for this sensor. If we did not have this sensor in stock the best option would be the SLTM20 due to it being the most resistant to high temperatures, has a better accuracy than the TC74, and is the cheapest unit.</p>"},{"location":"component_selection/#inner-casing-motor-driver","title":"Inner Casing Motor Driver","text":"<p>Table 7: Inner Casing Motor Driver Selecction</p> <ol> <li> <p>TI DRV8835 Motor Driver</p> <p></p> <ul> <li>$1.95/each</li> <li>Product Link</li> </ul> Pros Cons Cheap Lower top motor voltage Low Voltage Operation (VM input: 0-11V) Lots of pins to solder 1.5A continuous current </li> <li> <p>TI DRV8833 Motor Driver</p> <p></p> <ul> <li>$2.18/each</li> <li>Product Link</li> </ul> Pros Cons Built in current regulation Will shutdown at consistent high load Over temperature protection features Uses more MCU pins than others Compatible with 3.3V logic </li> <li> <p>TI DRV8838 Motor Driver</p> <p></p> <ul> <li>$1.03/each</li> <li>Product Link</li> </ul> Pros Cons Does not take up a lot of MCU I/O Solder using heat plate Up to 1.8A continuous current No stall handling built in Built in protections Needs good copper traces </li> </ol> <p>Choice: TI DRV8838 Motor Driver </p> <p>Rationale: The best choice is the TI DRV8838 Motor Driver as it satisfies our basic project needs while having manageable cons compared to other choices. Even though it will require a heat plate to solder and needs good copper traces, these can be easily learned and implemented. In contrast, a motor driver that will shutdown at a consistent high load or use more MCU pins could lead to substantial issues. Furthermore, this motor driver has slightly more headroom on continuous current. </p>"},{"location":"component_selection/#subsystem-5-wireless-communication","title":"Subsystem 5: Wireless Communication","text":"<p>Table 8: Wireless Communication Selection</p>"},{"location":"component_selection/#wireless-communication","title":"Wireless Communication","text":"<ol> <li> <p>ESP-NOW</p> <p></p> <ul> <li>N/A cost</li> <li>Product Link</li> </ul> Pros Cons Low latency Only pairs up to 20 devices Simple API (no low level programming) Only works with Espressif devices Easily integrates with ESP32 </li> <li> <p>ESP-MESH</p> <p></p> <ul> <li>N/A cost</li> <li>Product Link</li> </ul> Pros Cons Up to 10Mbps of data transfer Greater power consumption Mesh automatically forms More complex API Mesh self heals </li> <li> <p>Bluetooth (ESP-IDF)</p> <p></p> <ul> <li>N/A cost</li> <li>Product Link</li> </ul> Pros Cons Lots of documentation and examples Higher latency VS Code extension available Most complex API Security measures </li> </ol> <p>Choice: ESP-NOW </p> <p>Rationale: The best choice for wireless communication is ESP-NOW. Although it can only pair with up to 20 Espressif devices, our network topology only requires a single device to pair with four other ESP32s. Furthermore, the setup code is simpler compared to other communication protocols and has a lower latency, which is important for real-time wildfire prediction and detection. ESP-NOW can be set up to support a multi-hop network, which is required for our product. However, if this proves to be too difficult, the next best choice would be ESP-MESH. </p>"},{"location":"component_selection/#summary-table-of-major-components","title":"Summary Table of Major Components","text":"Part Name/Description Unit Quantity Unit Cost Manufacturer Manufacturer Part # Vendor Total Cost Order Total IC REG BUCK 3V 3A TO263 4 $3.32 Texas Instruments LM2596S-(3.3V)/NOPB Digikey $13.28 $168.73 9V 12 W AC/DC External Wall Mount (Class II) Adapter Fixed Blade Input 1 $6.23 GlobTek, Inc. 1939-WR9HD1333CCP-F(R6B)-ND Digikey $6.23 BME 280 Breakout Board 2 $8.99 HiLetgo GY-BME280-3.3 Amazon $17.98 LED RED DIFFUSED GULL WING SMD 5 $2.01 Broadcom Limited HLMP-Q150-F0011 Digikey $10.05 LED BLUE ROUND 4SMD 25 $1.20 Broadcom Limited ALMD-CB1E-VW002 Digikey $30.00 Junction box enclosure.  5.9\"D x 10.6\"W x 14.6\"H 1 $49.99 Gratury G Amazon $49.99 ESP32 Microcontroller 5 $5.06 Espressif Systems ESP32-S3-WROOM-1-N4 Digikey $25.30 ESP32 Snap Programmer 3 $5.30 M5 Stack S006 Electromaker $15.90"},{"location":"component_selection/#final-component-selection-decision-making-process","title":"Final Component Selection Decision Making Process","text":"<p>The final components were chosen based on simplicity, cost, available code libraries &amp; tutorials, and how well they fit the product requirements. All of the final components allow for Project Firesight to accomplish it's requirements. The switching voltage regulator provides stable power to the control panel and the weather station, which enables the product to function as intended. The BME 280 breakout board measures real-time environmental data to inform on wildfire susceptible areas. The LEDs are simple, but effective in indicating if an environmental threshold has been met and/or if a wildfire is susceptible in an area, which allows for a proactive approach to wildfire suppresion. The junction box is waterproof and durable, which protects the weather station components from the environment they are in, which is critical in maintaining product functionality. The snap programmer allows for the microcontroller to be programmed and the microcontroller controls the logic of the product, allowing for the transmission of real-time environmental data through ESP-NOW wireless communication. </p>"},{"location":"component_selection/#final-component-selection-feedback","title":"Final Component Selection Feedback","text":"<p>The teaching team advised to include an ESP32 Snap Programmer to the project's component list in case the USB programmer does not work. Thus, Electromaker's ESP32 Snap Programmer was added as a major component to Project Firesight. </p> <p>Note: The motor driver, DC motor, and internal temperature sensor were not included in the final prototype as the motor driver was unable to be properly soldered with the surface mount equipment provided at Peralta Lab. The OUT+ and OUT- pins that drive the motor would consistently short with the GND pin on the driver due to how small the driver and the pads were. Thus, the motor and related components are left out of the summary table as they were unused. </p>"},{"location":"component_selection/#battery-selection","title":"Battery Selection","text":""},{"location":"component_selection/#power-budget-weather-station","title":"Power Budget (Weather Station)","text":"Component Name Part Number Supply (V) # Absolute Current (mA) Total Current (mA) Subtotal Current (mA) Total Current Required (mA) ESP32-S3-WROOM-1 N4 3.3 - 3.6 1 500 500 3500.0036 4375.0045 IC REG BUCK 3.3V 3A TO263-5L LM2596S-3.3 4.75 - 40 1 3000 3000 BME 280 Breakout Board GY-BME280-3.3 1.71 - 3.6 1 0.0036 0.0036"},{"location":"component_selection/#power-budget-control-panel","title":"Power Budget (Control Panel)","text":"Component Name Part Number Supply (V) # Absolute Current (mA) Total Current (mA) Subtotal Current (mA) Total Current Required (mA) ESP32-S3-WROOM-1 N4 3.3 - 3.6 1 500 500 3622.0036 4527.5045 IC REG BUCK 3.3V 3A TO263-5L LM2596S-3.3 4.75 - 40 1 3000 3000 BME 280 Breakout Board GY-BME280-3.3 1.71 - 3.6 1 0.0036 0.0036 LED RED DIFFUSED GULL WING SMD HLMP-Q150-F0011 1.6 2 1 2 LED BLUE ROUND 4SMD ALMD-CB1E-VW002 3.2 6 20 120 <p>Note: The total current required was calculated by multiplying the subtotal current by 1.25 to provide a 25% safety margin. </p> <p>The power budget was used to estimate the battery capacity required for final demonstration. Even though the switching voltage regulator can draw a current of up to 3A, during testing, the weather station board only pulled 13 mA from the school lab bench top power supplies. As a lithium ion battery was utilized for its recharging capabilities, and the switching voltage regulator requires a minimum voltage greater than what a one cell lithium ion battery can provide (3.7V), the team chose the cheapest two cell lithium ion battery with recharging capabilities. The battery chosen was a 7.4V 5Ah lithium ion battery. The product link for the weather station battery is below. The control panel board is powered by a wall outlet through an AC-DC 9V barrel jack plug. </p> <p></p> <p>Cost: $16.99</p> <p>Product Link</p>"},{"location":"static/node_modules/mathjax/","title":"MathJax","text":""},{"location":"static/node_modules/mathjax/#mathjax","title":"MathJax","text":""},{"location":"static/node_modules/mathjax/#beautiful-math-in-all-browsers","title":"Beautiful math in all browsers","text":"<p>MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers.  It was designed with the goal of consolidating the recent advances in web technologies into a single, definitive, math-on-the-web platform supporting the major browsers and operating systems.  It requires no setup on the part of the user (no plugins to download or software to install), so the page author can write web documents that include mathematics and be confident that users will be able to view it naturally and easily.  Simply include MathJax and some mathematics in a web page, and MathJax does the rest.</p> <p>Some of the main features of MathJax include:</p> <ul> <li> <p>High-quality display of LaTeX, MathML, and AsciiMath notation in HTML pages</p> </li> <li> <p>Supported in most browsers with no plug-ins, extra fonts, or special   setup for the reader</p> </li> <li> <p>Easy for authors, flexible for publishers, extensible for developers</p> </li> <li> <p>Supports math accessibility, cut-and-paste interoperability, and other   advanced functionality</p> </li> <li> <p>Powerful API for integration with other web applications</p> </li> </ul> <p>See http://www.mathjax.org/ for additional details about MathJax, and https://docs.mathjax.org for the MathJax documentation.</p>"},{"location":"static/node_modules/mathjax/#mathjax-components","title":"MathJax Components","text":"<p>MathJax version 3 uses files called components that contain the various MathJax modules that you can include in your web pages or access on a server through NodeJS.  Some components combine all the pieces you need to run MathJax with one or more input formats and a particular output format, while other components are pieces that can be loaded on demand when needed, or by a configuration that specifies the pieces you want to combine in a custom way.  For usage instructions, see the MathJax documentation.</p> <p>Components provide a convenient packaging of MathJax's modules, but it is possible for you to form your own custom components, or to use MathJax's modules directly in a node application on a server.  There are web examples showing how to use MathJax in web pages and how to build your own components, and node examples illustrating how to use components in node applications or call MathJax modules directly.</p>"},{"location":"static/node_modules/mathjax/#whats-in-this-repository","title":"What's in this Repository","text":"<p>This repository contains only the component files for MathJax, not the source code for MathJax (which are available in a separate MathJax source repository).  These component files are the ones served by the CDNs that offer MathJax to the web.  In version 2, the files used on the web were also the source files for MathJax, but in version 3, the source files are no longer on the CDN, as they are not what are run in the browser.</p> <p>The components are stored in the <code>es5</code> directory, and are in ES5 format for the widest possible compatibility.  In the future, we may make an <code>es6</code> directory containing ES6 versions of the components.</p>"},{"location":"static/node_modules/mathjax/#installation-and-use","title":"Installation and Use","text":""},{"location":"static/node_modules/mathjax/#using-mathjax-components-from-a-cdn-on-the-web","title":"Using MathJax components from a CDN on the web","text":"<p>If you are loading MathJax from a CDN into a web page, there is no need to install anything.  Simply use a <code>script</code> tag that loads MathJax from the CDN.  E.g.,</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>See the MathJax documentation, the MathJax Web Demos, and the MathJax Component Repository for more information.</p>"},{"location":"static/node_modules/mathjax/#hosting-your-own-copy-of-the-mathjax-components","title":"Hosting your own copy of the MathJax Components","text":"<p>If you want to host MathJax from your own server, you can do so by installing the <code>mathjax</code> package using <code>npm</code> and moving the <code>es5</code> directory to an appropriate location on your server:</p> <pre><code>npm install mathjax@3\nmv node_modules/mathjax/es5 &lt;path-to-server-location&gt;/mathjax\n</code></pre> <p>Note that we are still making updates to version 2, so include <code>@3</code> when you install, since the latest chronological version may not be version 3.</p> <p>Alternatively, you can get the files via GitHub:</p> <pre><code>git clone https://github.com/mathjax/MathJax.git mj-tmp\nmv mj-tmp/es5 &lt;path-to-server-location&gt;/mathjax\nrm -rf mj-tmp\n</code></pre> <p>Then (in either case) you can use a script tag like the following:</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"&lt;url-to-your-site&gt;/mathjax/tex-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>where <code>&lt;url-to-your-site&gt;</code> is replaced by the URL to the location where you moved the MathJax files above.</p> <p>See the documentation for details.</p>"},{"location":"static/node_modules/mathjax/#using-mathjax-components-in-a-node-application","title":"Using MathJax components in a node application","text":"<p>To use MathJax components in a node application, install the <code>mathjax</code> package:</p> <pre><code>npm install mathjax@3\n</code></pre> <p>(we are still making updates to version 2, so you should include <code>@3</code> since the latest chronological version may not be version 3).</p> <p>Then require <code>mathjax</code> within your application:</p> <pre><code>require('mathjax').init({ ... }).then((MathJax) =&gt; { ... });\n</code></pre> <p>where the first <code>{ ... }</code> is a MathJax configuration, and the second <code>{ ... }</code> is the code to run after MathJax has been loaded.  E.g.</p> <pre><code>require('mathjax').init({\n  loader: {load: ['input/tex', 'output/svg']}\n}).then((MathJax) =&gt; {\n  const svg = MathJax.tex2svg('\\\\frac{1}{x^2-1}', {display: true});\n  console.log(MathJax.startup.adaptor.outerHTML(svg));\n}).catch((err) =&gt; console.log(err.message));\n</code></pre> <p>Note: this technique is for node-based application only, not for browser applications.  This method sets up an alternative DOM implementation, which you don't need in the browser, and tells MathJax to use node's <code>require()</code> command to load external modules.  This setup will not work properly in the browser, even if you webpack it or bundle it in other ways.</p> <p>See the documentation and the MathJax Node Repository for more details.</p>"},{"location":"static/node_modules/mathjax/#reducing-the-size-of-the-components-directory","title":"Reducing the Size of the Components Directory","text":"<p>Since the <code>es5</code> directory contains all the component files, so if you are only planning one use one configuration, you can reduce the size of the MathJax directory by removing unused components. For example, if you are using the <code>tex-chtml.js</code> component, then you can remove the <code>tex-mml-chtml.js</code>, <code>tex-svg.js</code>, <code>tex-mml-svg.js</code>, <code>tex-chtml-full.js</code>, and <code>tex-svg-full.js</code> configurations, which will save considerable space.  Indeed, you should be able to remove everything other than <code>tex-chtml.js</code>, and the <code>input/tex/extensions</code>, <code>output/chtml/fonts/woff-v2</code>, <code>adaptors</code>, <code>a11y</code>, and <code>sre</code> directories.  If you are using the results only on the web, you can remove <code>adaptors</code> as well.</p> <p>If you are not using A11Y support (e.g., speech generation, or semantic enrichment), then you can remove <code>a11y</code> and <code>sre</code> as well (though in this case you may need to disable the assistive tools in the MathJax contextual menu in order to avoid MathJax trying to load them when they aren't there).</p> <p>If you are using SVG rather than CommonHTML output (e.g., <code>tex-svg.js</code> rather than <code>tex-chtml.js</code>), you can remove the <code>output/chtml/fonts/woff-v2</code> directory.  If you are using MathML input rather than TeX (e.g., <code>mml-chtml.js</code> rather than <code>tex-chtml.js</code>), then you can remove <code>input/tex/extensions</code> as well.</p>"},{"location":"static/node_modules/mathjax/#the-component-files-and-pull-requests","title":"The Component Files and Pull Requests","text":"<p>The <code>es5</code> directory is generated automatically from the contents of the MathJax source repository.  You can rebuild the components using the command</p> <pre><code>npm run make-es5 --silent\n</code></pre> <p>Note that since the contents of this repository are generated automatically, you should not submit pull requests that modify the contents of the <code>es5</code> directory.  If you wish to submit a modification to MathJax, you should make a pull request in the MathJax source repository.</p>"},{"location":"static/node_modules/mathjax/#mathjax-community","title":"MathJax Community","text":"<p>The main MathJax website is http://www.mathjax.org, and it includes announcements and other important information.  A MathJax user forum for asking questions and getting assistance is hosted at Google, and the MathJax bug tracker is hosted at GitHub.</p> <p>Before reporting a bug, please check that it has not already been reported.  Also, please use the bug tracker (rather than the help forum) for reporting bugs, and use the user's forum (rather than the bug tracker) for questions about how to use MathJax.</p>"},{"location":"static/node_modules/mathjax/#mathjax-resources","title":"MathJax Resources","text":"<ul> <li>MathJax Documentation</li> <li>MathJax Components</li> <li>MathJax Source Code</li> <li>MathJax Web Examples</li> <li>MathJax Node Examples</li> <li>MathJax Bug Tracker</li> <li>MathJax Users' Group</li> </ul>"}]}